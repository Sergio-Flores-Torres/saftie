import { GetSaftieAction, PostSaftieAction } from "wasp/server/api"; // This type is generated by Wasp based on the `api` declaration above.
import { ActionGetResponse, ActionPostResponse, CreateActionPostResponseArgs, createPostResponse } from "@solana/actions";

import {
    getAssociatedTokenAddressSync,
    createTransferInstruction,
} from "@solana/spl-token";
  
import {
    Connection,
    PublicKey,
    TransactionMessage,
    VersionedTransaction,
    Keypair,
    ParsedAccountData,
    ComputeBudgetProgram,
	Transaction,
} from "@solana/web3.js";

export const getSaftieAction: GetSaftieAction = async (req, res, context) => {
  res.set("Access-Control-Allow-Origin", "*"); // Example of modifying headers to override Wasp default CORS middleware.
  res.set("Access-Control-Allow-Methods", "GET,POST,PUT,OPTIONS"); 
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization, Content-Encoding, Accept-Encoding"); 

  const actionResponse: ActionGetResponse = {
	icon: "https://saftie.saft.industries/src/client/static/saftie.png",
	title: "Saftie, frictionless Solana donation blinks",
	description: "There was a problem locating your Saftie :/",
	label: "Send!",
  };

  const saftie = await context.entities.Saftie.findUnique({where:{id: req.params.id}});

  if (saftie) {
	actionResponse.description = `Send a donation of ${saftie?.amount} USDC to address ${saftie?.address}`;
  } else {
	actionResponse.disabled = true;
	actionResponse.error = {message: "Cannot send a donation without a correct id."};
  }

  res.json(actionResponse);
};

export const postSaftieAction: PostSaftieAction = async (req, res, context) => {
	res.set("Access-Control-Allow-Origin", "*"); // Example of modifying headers to override Wasp default CORS middleware.
	res.set("Access-Control-Allow-Methods", "GET,POST,PUT,OPTIONS"); 
	res.set("Access-Control-Allow-Headers", "Content-Type, Authorization, Content-Encoding, Accept-Encoding"); 
  
	try {

		const saftie = await context.entities.Saftie.findUnique({where:{id: req.params.id}});

		if (!saftie)
			throw new Error("Cannot find Saftie :/");

		const senderAddress = req.body.account;

		if (!senderAddress)
			throw new Error("Invalid sender.");

		// Address receiving/sending the tokens
		const receiverPubkey = new PublicKey(saftie?.address!);
		const senderPubkey = new PublicKey(senderAddress);
		
		// The SLP token being transferred, this is the address for USDC
		const mintAddress = new PublicKey(process.env.SOLANA_USDC!);

		// Get the associated token accounts for the sender and receiver.
		const senderATAPubkey = getAssociatedTokenAddressSync(
			senderPubkey,
			mintAddress,
		);
		const receiverATAPubkey = getAssociatedTokenAddressSync(
			receiverPubkey,
			mintAddress,
		);

		// Adjusts the transfer amount according to the token's decimals to ensure accurate transfers.
		const transferAmountInDecimals = saftie?.amount! * Math.pow(10, 6); // USDC has 6
		
		// Prepares the transfer instructions with all necessary information.
		const transferInstruction = createTransferInstruction(
			// Those addresses are the Associated Token Accounts belonging to the sender and receiver
			senderATAPubkey,
			receiverATAPubkey,
			senderPubkey,
			transferAmountInDecimals
		);
		console.log(
			`Transaction instructions: ${JSON.stringify(transferInstruction)}`
		);

		const connection = new Connection(process.env.SOLANA_RPC_URL!, "confirmed");

		// Assemble token transfer tx here
		// get the latest blockhash amd block height
		const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();

		// create a legacy transaction
		const transaction = new Transaction({
			feePayer: senderPubkey,
			blockhash,
			lastValidBlockHeight,
		}).add(transferInstruction);

		const actionResponse:ActionPostResponse = await createPostResponse({
			fields: {
				type: "transaction",
				transaction: transaction,
				message: `Send a donation of ${saftie?.amount} USDC to address ${saftie?.address}`,
			},
			// note: no additional signers are needed
			// signers: [],
		});
	
		res.json(actionResponse);

	} catch (error) {
		res.status(500).json({message: (error as Error).message});
	}
  };